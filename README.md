## 研究目的
探究Flink检查点间隔对性能与容错能力的影响

## 研究内容
深入理解Flink的检查点（Checkpoint）机制，探究检查点间隔对系统性能和故障恢复能力的影响。进一步分析不同间隔设置下的性能权衡，研究如何选择合适的检查点间隔以在性能与容错之间取得平衡。

## 实验

### 实验环境
* 硬件：集群配置，包括节点数 **(>=3)**、CPU 核数、内存大小、网络带宽、存储类型（SSD / HDD）等。
  * 节点数：3，jobmanager: 1 taskmanager：2

  * CPU 核数：4核

  * 内存大小：8G

  * 网络带宽 ：1000M

  * 存储类型 ：HDD

* 软件：操作系统、JDK 版本、各框架版本等。
  * 操作系统：Ubuntu 20.04.3 LTS
  * JDK 版本：11.0.26
  * flink版本：1.18.1
  * maven版本：3.8.6


### 实验负载
本实验采用自定义 Nexmark 负载，以模拟典型流处理系统中高吞吐、大状态、频繁检查点的复杂场景。在标准 Nexmark 基础上，本负载加强了状态规模，以支撑对检查点策略（如间隔、状态大小）与系统性能之间权衡关系的定量分析。

#### 数据集生成机制

- **数据格式**：每条记录为三元组 `(auctionId, bidderId, price)`，其中：
  - `auctionId`：拍卖商品 ID，取值范围 `[0, maxAuctionId)`，用于窗口聚合。
  - `bidderId`：竞标者 ID，取值范围 `[0, 3,000,000)`，作为**大状态键**（key-by bidder）。
  - `price`：出价金额，范围 `[1, 5000]`，用于未来扩展（当前未使用）。
- **数据源**：基于 Flink `DataGeneratorSource` 构建，支持**恒定吞吐率**（默认 15,000 条/秒）与**无限数据流**，确保长时间运行下的稳定性与压力
- **可配置参数**：
  - `rate`：事件生成速率（events/s），用于控制输入负载强度。
  - `keys`（即 `maxAuctionId`）：控制聚合键空间大小，影响窗口并行度与状态分布。
  - `stateMode`：状态大小模式（`bigstate` / `realistic` / `hybrid`），直接影响状态后端存储压力。

#### 工作负载特性

工作负载分为两个阶段，分别模拟状态密集型处理与窗口聚合计算

- **状态操作**：

  - 每个 `bidderId` 关联一个 `byte[]` 状态对象。状态大小分配：
    - `bigstate`：20KB–200KB/键，模拟极端大状态。
    - `realistic`：0.5KB–1.5KB/键，接近实际用户画像场景。
    - `hybrid`：80% 键使用 1KB，20% 使用 50KB，模拟长尾分布。
  - 每次处理事件时，随机修改状态中的字节，触发状态更新与检查点写入。
  - **设计目的**：制造显著的**状态写入压力**与**检查点数据量波动**，用于评估不同检查点间隔下 I/O 开销与恢复效率。
  
- ##### 窗口聚合阶段（Window-Aggregation）

  - **窗口策略**：滑动处理时间窗口，窗口长度 10 秒，滑动步长 2 秒。对每个 `auctionId` 统计窗口内事件数量，模拟统计该段时间内的商品点击次数
  - **输出内容**：元组 `(auctionId, count)`
  - **设计目的**：引入**高频窗口触发**（每 2 秒一次），增加作业调度与状态清理负担。

### 实验步骤
列出执行实验的关键步骤，并对关键步骤进行截图，如 MapReduce / Spark / Flink 部署成功后的进程信息、作业执行成功的信息等，**截图能够通过显示用户账号等个性化信息佐证实验的真实性**。

#### **步骤 1：环境准备与 Flink 集群启动**

在多机环境中确保 Flink 已正确部署

每台主机单独部署docker容器进行实验：

jobmanage

![image-20251212185202481](.\assets\image-20251212185202481.png)

taskmanage-1

![image-20251212190323830](.\assets\image-20251212190323830.png)



taskmanage-2

![image-20251212190446719](.\assets\image-20251212190446719.png)

#### **步骤 2：编译并打包实验程序**

使用 Maven 构建，生成可执行的  JAR

编译脚本：

![image-20251212190031215](.\assets\image-20251212190031215.png)

编译成功：

![image-20251212191431374](.\assets\image-20251212191431374.png)

#### **步骤 3：提交 Flink 作业**

使用 `flink run` 提交作业，并传入实验参数

提交脚本：

![image-20251212190650600](.\assets\image-20251212190650600.png)

提交成功

![image-20251212191348573](.\assets\image-20251212191348573.png)

#### **步骤 4：验证作业运行状态**

通过 Flink Web UI确认作业正在运行

![image-20251212191535606](.\assets\image-20251212191535606.png)

#### **步骤 5：监控端到端延迟指标**

利用python代码，通过 Flink REST API收集指标

### 实验结果与分析


### 结论


### 分工
